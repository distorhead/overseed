#!/usr/bin/env python3

import subprocess
import argparse
import hashlib
import daemonize
import os
import sys


class Application:
  def __init__(self):
    pass

  def action_main(self, args):
    print("action_main({}, {})".format(self, args))

  def action_init(self, args):
    print("action_init({}, {})".format(self, args))

  def action_start(self, args):
    print("action_start({}, {})".format(self, args))

  def action_stop(self, args):
    print("action_stop({}, {})".format(self, args))

  def action_destroy(self, args):
    print("action_destroy({}, {})".format(self, args))


CONFIG = {
  'events': ['modify', 'move', 'create', 'delete'],
  'exclude': ['\.git', '.*\.swp', '.*\.swx', '.*\.swo'],
  'on_event': [
    "/usr/bin/ctags -R -f .tags"
  ],
  'inotifywait': "/usr/bin/inotifywait"
}


def call_cmd(cmd):
  print("== cmd: {cmd}".format(cmd=cmd))
  return subprocess.call(cmd, shell=True)


def inotify_waiter(cfg):
  cmd = "{} -r .".format(cfg['inotifywait'])

  events = cfg['events']
  if events:
    cmd += " -e {}".format(",".join(events))

  exclude = cfg['exclude']
  if exclude:
    cmd += " --exclude='({})'".format("|".join(exclude))

  return call_cmd(cmd)


def event_handler(cfg):
  for cmd in cfg['on_event']:
    call_cmd(cmd)


def watcher_loop(target):
  os.chdir(target)
  event_handler(CONFIG)
  while True:
    res = inotify_waiter(CONFIG)
    if res == 0:
      event_handler(CONFIG)


def make_pidpath(target):
  cwd = target.encode('utf-8')
  pid = "/run/overseed/{}.pid".format(hashlib.md5(cwd).hexdigest())
  return pid


def get_pid(pidpath):
  try:
    f = open(pidpath, 'r')
    pidstr = f.read()
  except Exception as e:
    print("Unable to read daemon pid from '{pidpath}'".format(pidpath=pidpath), file=sys.stderr)
    sys.exit(1)

  try:
    return int(pidstr)
  except Exception as e:
    print("Bad pid '{pidstr}'".format(pidstr=pidstr))
    sys.exit(1)


def kill(pid):
  call_cmd("kill {pid}".format(pid=pid))


def main():
  app = Application()

  parser = argparse.ArgumentParser(description='Super inotify watcher script')
  parser.add_argument('base_directory', metavar='BASE_DIRECTORY',
                      help='Base working directory')

  subparsers = parser.add_subparsers(title='actions', description='Valid actions:')

  sparser = subparsers.add_parser('init', help='Initialize overseed environment')
  sparser.set_defaults(action_callback=app.action_init)

  sparser = subparsers.add_parser('start', help='Start overseed')
  sparser.add_argument('-r', '--no-daemonize', action='store_true', default=False,
                      help='Do not daeminze overseed')
  sparser.set_defaults(action_callback=app.action_start)

  sparser = subparsers.add_parser('stop', help='Stop overseed')
  sparser.set_defaults(action_callback=app.action_stop)

  sparser = subparsers.add_parser('destroy', help='Destroy overseed environment')
  sparser.set_defaults(action_callback=app.action_destroy)

  args = parser.parse_args()
  args_dict = vars(args)
  args.action_callback(args_dict)

  #KILLITWITHFIRE

  #args.watch = os.path.abspath(args.watch)

  #if args.stop:
    #pp = make_pidpath(args.watch)
    #pid = get_pid(pp)
    #kill(pid)
    #os.unlink(pp)

  #elif args.daemonize:
    #pid = make_pidpath(args.watch)
    #print("pid: {pid}".format(pid=pid))
    #daemon = daemonize.Daemonize(app="overseed", pid=pid, action=lambda: watcher_loop(args.watch))
    #daemon.start()

  #else:
    #watcher_loop(args.watch)


if __name__ == '__main__':
  main()
